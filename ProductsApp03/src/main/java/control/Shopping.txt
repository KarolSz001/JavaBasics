package manager;

import model.Customer;
import model.Product;
import paresTemp.FileTxtOperations;

import java.math.BigDecimal;
import java.util.*;
import java.util.function.Function;
import java.util.stream.Collectors;

public class Shopping {


    private Map<Customer, Map<Product, Integer>> customerMapMap;

    public Shopping(String fileNameList) {
        this.customerMapMap = FileTxtOperations.readAllFiles(fileNameList);
    }

    public Map<Customer, Map<Product, Integer>> getCustomerMapMap() {
        return customerMapMap;
    }

    public void setCustomerMapMap(Map<Customer, Map<Product, Integer>> customerMapMap) {
        this.customerMapMap = customerMapMap;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Shopping shopping = (Shopping) o;
        return Objects.equals(customerMapMap, shopping.customerMapMap);
    }

    @Override
    public int hashCode() {
        return Objects.hash(customerMapMap);
    }

    @Override
    public java.lang.String toString() {
        return "Shopping{" +
                "customerMapMap=" + customerMapMap +
                '}';
    }
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    /* 1 Designate the customer who paid the most for all purchases.
In a separate method, designate the customer who paid the most
for shopping in the selected category. Give the category name as
function argument.*/

    public Map<Customer, Integer> whoPaidMost() {
        Map<Customer, Integer> paidMost = customerMapMap.entrySet()
                .stream()
                .collect(Collectors.toMap(
                        k -> k.getKey(),
                        v -> v.getValue().entrySet().stream().map(s -> s.getKey().getPrice().multiply(new BigDecimal(s.getValue()))).reduce(BigDecimal.ZERO, (p1, p2) -> p1.add(p2))
                ))
                .entrySet()
                .stream()
                .sorted(Comparator.comparingInt(s -> s.getValue().intValue() * (-1)))
                .collect(Collectors.toMap(
                        e -> e.getKey(),
                        e -> e.getValue().intValue(),
                        (v1, v2) -> Integer.max(v1, v2),
                        () -> new LinkedHashMap<>()
                ));
        return paidMost;
    }

    public Customer whoPaidMost2() {
        Customer paidMost = customerMapMap.entrySet()
                .stream()
                .collect(Collectors.toMap(
                        k -> k.getKey(),
                        v -> v.getValue().entrySet().stream().map(s -> s.getKey().getPrice().multiply(new BigDecimal(s.getValue())))
                                .reduce(BigDecimal.ZERO, (p1, p2) -> p1.add(p2))
                ))
                .entrySet()
                .stream()
                .sorted(Comparator.comparingInt(s -> s.getValue().intValue() * (-1)))
                .findFirst()
                .orElseThrow(NullPointerException::new)
                .getKey();
        return paidMost;
    }
//v-> v.getValue().entrySet().stream().map(s->s.getKey().getPrice().multiply(new BigDecimal(s.getValue()))).reduce(BigDecimal.ZERO,(p1,p2)->p1.add(p2))

/*
*Wykonaj zestawienie (mapę), w którym pokażesz wiek klientów oraz
kategorie produktów, które najchętniej w tym wieku kupowano.*/

public Map<Integer, String> task2() {

            return customerMapMap.entrySet()
                    .stream()
                    .collect(Collectors.toMap(
                            e -> e.getKey(),
                            e -> e.getValue()
                                    .entrySet()
                                    .stream()
                                    // remember metode !!!!!!!
                                    .map(ee -> Collections.nCopies(ee.getValue(), ee.getKey().getCategory()))
                                    .flatMap(t -> t.stream())
                                    .collect(Collectors.toList())
                            )

                    )
                    .entrySet()
                    .stream()
                    .collect(Collectors.groupingBy(e -> e.getKey().getAge()))
                    .entrySet()
                    .stream()
                    .collect(Collectors.toMap(
                            ee -> ee.getKey(),
                            ee -> ee.getValue().stream().map(x -> x.getValue()).flatMap(t -> t.stream()).collect(Collectors.toList())
                    ))
                    .entrySet()
                    .stream()
                    .collect(Collectors.toMap(
                                e -> e.getKey(),
                                e -> e.getValue()
                                        .stream()
                                        .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()))
                                        .entrySet()
                                        .stream()
                                        .sorted((ee1, ee2) -> Long.compare(ee1.getValue(), ee2.getValue()))
                                        .findFirst()
                                        .orElseThrow(() -> new NullPointerException("ERROR"))
                                        .getKey()
                            )
                    );
}


}




